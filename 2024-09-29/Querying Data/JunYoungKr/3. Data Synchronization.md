## React Query가 서버 상태와 클라이언트 상태 간의 동기화를 어떻게 관리하는지? 캐시 무효화 및 데이터 동기화 문제를 다룬다

컴퓨터 과학에서 두 가지 어려운 문제 중 하나는 캐시 무효화이다.

React Query는 이 복잡성을 어떻게 처리할까?
간단히 말해, 서버에서 가져온 데이터가 화면에 표시된 상태와 가능한 한 동기화되도록 유지하려고 한다.

하지만 서버 상태는 언제든 변경될 수 있기 때문에 React Query는 데이터 동기화 도구라고 생각할 수 있다.

한 어플이 있다고 가정 후 아침에 어플을 열고 몇 시간 후에 다시 돌아왔다면, 클라이언트의 상태가 서버의 상태와 일치할 확률은 거의 없을 것이다.

이 문제를 해결하려면, 언제 캐시된 값이 무효화되어 서버 상태와 다시 동기화되어야 할지를 결정해야 한다.

```js
cache-control: public, max-age=60
```

대부분의 **캐시의 기본 설정**은 일정 시간이 지나면 캐시를 무효화하는 것이다.
위 코드는 `GitHub API`에서의 응답에서 `cache-control` 헤더를 보면, 60초 동안 동일한 URL에 대한 요청을 하지 말라고 브라우저에 지시한다.

대신, 브라우저 캐시에 리소스를 제공한다.
여기서 말하는 `리소스`란 브라우저 캐시에 저장된 이전의 서버 응답 데이터를 의미한다.

문제는 React Query가 요청을 직접 실행하지 않기에 `cache-control` 헤더에 대해 알지 못한다는 것이다.

다행히 React Query에는 비슷한 개념인 `staleTime`이 있다.
**stale**이란 오래된이란 뜻인데, **fresh**(신선한)의 반대이다.
쿼리가 신선한 것으로 간주되는 한, 데이터는 캐시에서만 제공된다.
그리고 `staleTime`은 쿼리가 `stale` 상태로 간주되기까지의 시간을 정의한다.

예를 들어, React Query에서 staleTime을 60초로 설정하면, 그 시간 동안 `queryFn`이 실행되지 않게 된다.
하지만 기본 `staleTime` 값은 0이다. 즉, 모든 쿼리는 즉시 stale 상태가 된다.
이는 종종 서버에서 불필요하게 자주 데이터를 가져올 수 있지만, 반대로 데이터가 오래된 상태로 남는 것보다는 낫다.

또한, 기본 값이 0이 아니라면, 더 나은 기본 값은 무엇일까?
20초, 30초, 1분 등 이는 모든 상황에 따라 다르다.

구체적으로 말하자면, `리소스`에 따라 달라진다.

- 얼마나 자주 업데이트 되는지?
- 화면에 표시되는 데이터가 얼마나 정확해야 하는지?
- 협업이 얼마나 중요한 환경인지?

등 개발자는 이에 맞게 결정해야 한다.

이 모든 것을 염두에 두고, React Query는 기본적으로 데이터를 가능한 한 최신 상태로 유지하려고 하며,
데이터를 가져오자마자 즉시 오래된 상태라고 가정한다.
물론 이에 동의하지 않으면 `staleTime`을 쉽게 커스터마이즈할 수 있다.

```js
useQuery({
  queryKey: ["repos", { sort }],
  queryFn: () => fetchRepos(sort),
  staleTime: 5 * 1000, // 5,000 ms or 5 seconds
});
```

만약 위처럼 `useQuery`에 `staleTime`을 5000으로 설정하면, React Query는 데이터가 5초 이상 오래되지 않은 한 쿼리를 오래된 상태로 만들지 않는다.

그렇다면 쿼리가 오래된다면 어떻게 될까?
정답은 아무 일도 일어나지 않는다는 것이다.
오래된 쿼리는 단지 React Query에게 적절한 시점에 캐시를 백그라운드에서 업데이트하라고 지시할 뿐이다.

쿼리가 오래된 경우, 데이터를 제공한 후 React Query는 백그라운드에서 다시 동기화하여 캐시를 업데이트한다.
React Query가 발명한 것은 아니며, `Stale While Revalidate`라는 전략으로 알려져 있다.
이 전략이 강력한 이유는 React Query가 애플리케이션의 사용자 경험(UX)을 최적화하면서도 백그라운드에서 데이터를 최신 상태로 유지할 수 있기 때문이다.

**오래된 데이터라도 없는 것보다는 낫다**는 원칙이다.

이와 관련하여 마지막 질문이 남는다.
React Query는 정확히 언제 데이터를 다시 가져와 캐시를 업데이트 해야할까?

이러한 작업이 일어나는 4가지 시나리오가 있다.

1. **쿼리 키가 변경될 때** 이것은 위의 예시에서 정렬 값이 변경될 때 발생하는 트리거이다.
   쿼리 키가 변경되고 쿼리가 오래된 상태라면, React Query는 데이터를 다시 가져와 캐시를 업데이트 한다.

2. **새로운 관찰자가 마운트될 떄** 관찰자는 `useQuery`로 생성된다.
   화면에 새 컴포넌트가 마운트될 때 쿼리가 오래된 상태라면, React Query는 데이터를 다시 가져와 캐시를 업데이트한다.

3. **창에 포커스 이벤트가 발생할 때**
   사용자가 앱이 실행 중인 탭으로 다시 전환할 때, 쿼리가 오래된 상태라면 React Query는 데이터를 다시 가져와 캐시를 업데이트한다.

4. **장치가 다시 온라인 상태가 될 때**
   장치가 오프라인 상태였다가 다시 연결될 때 React Query는 데이터를 다시 가져와 캐시를 업데이트한다.

**다만, 데이터를 다시 가져오는 것이 캐시에서 데이터를 어떻게 제공하는지에는 전혀 영향을 미치지 않는다는 점을 기억하자**
React Query는 캐시된 데이터가 존재하는 한, 그 데이터가 신선하지 않더라도 항상 캐시에서 데이터를 제공한다.
`staleTime`은 단지 트리거가 발생할 때 React Query가 백그라운드에서 캐시를 업데이트해야 할 시점을 알려주는 역할을 한다.
